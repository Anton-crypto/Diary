{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/toni_/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Diary/Diary/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { HarnessPredicate, parallel, ComponentHarness } from '@angular/cdk/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Harness for interacting with a standard Material inputs in tests. */\n\nclass MatInputHarness extends MatFormFieldControlHarness {\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatInputHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which input instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options = {}) {\n    return new HarnessPredicate(MatInputHarness, options).addOption('value', options.value, (harness, value) => {\n      return HarnessPredicate.stringMatches(harness.getValue(), value);\n    }).addOption('placeholder', options.placeholder, (harness, placeholder) => {\n      return HarnessPredicate.stringMatches(harness.getPlaceholder(), placeholder);\n    });\n  }\n  /** Whether the input is disabled. */\n\n\n  isDisabled() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this.host()).getProperty('disabled');\n    })();\n  }\n  /** Whether the input is required. */\n\n\n  isRequired() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this2.host()).getProperty('required');\n    })();\n  }\n  /** Whether the input is readonly. */\n\n\n  isReadonly() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this3.host()).getProperty('readOnly');\n    })();\n  }\n  /** Gets the value of the input. */\n\n\n  getValue() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // The \"value\" property of the native input is never undefined.\n      return yield (yield _this4.host()).getProperty('value');\n    })();\n  }\n  /** Gets the name of the input. */\n\n\n  getName() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      // The \"name\" property of the native input is never undefined.\n      return yield (yield _this5.host()).getProperty('name');\n    })();\n  }\n  /**\n   * Gets the type of the input. Returns \"textarea\" if the input is\n   * a textarea.\n   */\n\n\n  getType() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // The \"type\" property of the native input is never undefined.\n      return yield (yield _this6.host()).getProperty('type');\n    })();\n  }\n  /** Gets the placeholder of the input. */\n\n\n  getPlaceholder() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const host = yield _this7.host();\n      const [nativePlaceholder, fallback] = yield parallel(() => [host.getProperty('placeholder'), host.getAttribute('data-placeholder')]);\n      return nativePlaceholder || fallback || '';\n    })();\n  }\n  /** Gets the id of the input. */\n\n\n  getId() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      // The input directive always assigns a unique id to the input in\n      // case no id has been explicitly specified.\n      return yield (yield _this8.host()).getProperty('id');\n    })();\n  }\n  /**\n   * Focuses the input and returns a promise that indicates when the\n   * action is complete.\n   */\n\n\n  focus() {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this9.host()).focus();\n    })();\n  }\n  /**\n   * Blurs the input and returns a promise that indicates when the\n   * action is complete.\n   */\n\n\n  blur() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this10.host()).blur();\n    })();\n  }\n  /** Whether the input is focused. */\n\n\n  isFocused() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this11.host()).isFocused();\n    })();\n  }\n  /**\n   * Sets the value of the input. The value will be set by simulating\n   * keypresses that correspond to the given value.\n   */\n\n\n  setValue(newValue) {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      const inputEl = yield _this12.host();\n      yield inputEl.clear(); // We don't want to send keys for the value if the value is an empty\n      // string in order to clear the value. Sending keys with an empty string\n      // still results in unnecessary focus events.\n\n      if (newValue) {\n        yield inputEl.sendKeys(newValue);\n      } // Some input types won't respond to key presses (e.g. `color`) so to be sure that the\n      // value is set, we also set the property after the keyboard sequence. Note that we don't\n      // want to do it before, because it can cause the value to be entered twice.\n\n\n      yield inputEl.setInputValue(newValue);\n    })();\n  }\n\n} // TODO: We do not want to handle `select` elements with `matNativeControl` because\n// not all methods of this harness work reasonably for native select elements.\n// For more details. See: https://github.com/angular/components/pull/18221.\n\n\nMatInputHarness.hostSelector = '[matInput], input[matNativeControl], textarea[matNativeControl]';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Harness for interacting with a native `option` in tests. */\n\nclass MatNativeOptionHarness extends ComponentHarness {\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatNativeOptionHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which option instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options = {}) {\n    return new HarnessPredicate(MatNativeOptionHarness, options).addOption('text', options.text, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (harness, title) {\n        return HarnessPredicate.stringMatches(yield harness.getText(), title);\n      });\n\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }()).addOption('index', options.index, /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (harness, index) {\n        return (yield harness.getIndex()) === index;\n      });\n\n      return function (_x3, _x4) {\n        return _ref2.apply(this, arguments);\n      };\n    }()).addOption('isSelected', options.isSelected, /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (harness, isSelected) {\n        return (yield harness.isSelected()) === isSelected;\n      });\n\n      return function (_x5, _x6) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n  }\n  /** Gets the option's label text. */\n\n\n  getText() {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this13.host()).getProperty('label');\n    })();\n  }\n  /** Index of the option within the native `select` element. */\n\n\n  getIndex() {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this14.host()).getProperty('index');\n    })();\n  }\n  /** Gets whether the option is disabled. */\n\n\n  isDisabled() {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this15.host()).getProperty('disabled');\n    })();\n  }\n  /** Gets whether the option is selected. */\n\n\n  isSelected() {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this16.host()).getProperty('selected');\n    })();\n  }\n\n}\n/** Selector used to locate option instances. */\n\n\nMatNativeOptionHarness.hostSelector = 'select[matNativeControl] option';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Harness for interacting with a native `select` in tests. */\n\nclass MatNativeSelectHarness extends MatFormFieldControlHarness {\n  /**\n   * Gets a `HarnessPredicate` that can be used to search for a `MatNativeSelectHarness` that meets\n   * certain criteria.\n   * @param options Options for filtering which select instances are considered a match.\n   * @return a `HarnessPredicate` configured with the given options.\n   */\n  static with(options = {}) {\n    return new HarnessPredicate(MatNativeSelectHarness, options);\n  }\n  /** Gets a boolean promise indicating if the select is disabled. */\n\n\n  isDisabled() {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this17.host()).getProperty('disabled');\n    })();\n  }\n  /** Gets a boolean promise indicating if the select is required. */\n\n\n  isRequired() {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this18.host()).getProperty('required');\n    })();\n  }\n  /** Gets a boolean promise indicating if the select is in multi-selection mode. */\n\n\n  isMultiple() {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this19.host()).getProperty('multiple');\n    })();\n  }\n  /** Gets the name of the select. */\n\n\n  getName() {\n    var _this20 = this;\n\n    return _asyncToGenerator(function* () {\n      // The \"name\" property of the native select is never undefined.\n      return yield (yield _this20.host()).getProperty('name');\n    })();\n  }\n  /** Gets the id of the select. */\n\n\n  getId() {\n    var _this21 = this;\n\n    return _asyncToGenerator(function* () {\n      // We're guaranteed to have an id, because the `matNativeControl` always assigns one.\n      return yield (yield _this21.host()).getProperty('id');\n    })();\n  }\n  /** Focuses the select and returns a void promise that indicates when the action is complete. */\n\n\n  focus() {\n    var _this22 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this22.host()).focus();\n    })();\n  }\n  /** Blurs the select and returns a void promise that indicates when the action is complete. */\n\n\n  blur() {\n    var _this23 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this23.host()).blur();\n    })();\n  }\n  /** Whether the select is focused. */\n\n\n  isFocused() {\n    var _this24 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this24.host()).isFocused();\n    })();\n  }\n  /** Gets the options inside the select panel. */\n\n\n  getOptions(filter = {}) {\n    var _this25 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this25.locatorForAll(MatNativeOptionHarness.with(filter))();\n    })();\n  }\n  /**\n   * Selects the options that match the passed-in filter. If the select is in multi-selection\n   * mode all options will be clicked, otherwise the harness will pick the first matching option.\n   */\n\n\n  selectOptions(filter = {}) {\n    var _this26 = this;\n\n    return _asyncToGenerator(function* () {\n      const [isMultiple, options] = yield parallel(() => {\n        return [_this26.isMultiple(), _this26.getOptions(filter)];\n      });\n\n      if (options.length === 0) {\n        throw Error('Select does not have options matching the specified filter');\n      }\n\n      const [host, optionIndexes] = yield parallel(() => [_this26.host(), parallel(() => options.slice(0, isMultiple ? undefined : 1).map(option => option.getIndex()))]);\n      yield host.selectOptions(...optionIndexes);\n    })();\n  }\n\n}\n\nMatNativeSelectHarness.hostSelector = 'select[matNativeControl]';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { MatInputHarness, MatNativeOptionHarness, MatNativeSelectHarness };","map":{"version":3,"sources":["C:/Users/toni_/OneDrive/Рабочий стол/Diary/Diary/ClientApp/node_modules/@angular/material/fesm2020/input/testing.mjs"],"names":["HarnessPredicate","parallel","ComponentHarness","MatFormFieldControlHarness","MatInputHarness","with","options","addOption","value","harness","stringMatches","getValue","placeholder","getPlaceholder","isDisabled","host","getProperty","isRequired","isReadonly","getName","getType","nativePlaceholder","fallback","getAttribute","getId","focus","blur","isFocused","setValue","newValue","inputEl","clear","sendKeys","setInputValue","hostSelector","MatNativeOptionHarness","text","title","getText","index","getIndex","isSelected","MatNativeSelectHarness","isMultiple","getOptions","filter","locatorForAll","selectOptions","length","Error","optionIndexes","slice","undefined","map","option"],"mappings":"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","sourcesContent":["import { HarnessPredicate, parallel, ComponentHarness } from '@angular/cdk/testing';\nimport { MatFormFieldControlHarness } from '@angular/material/form-field/testing/control';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Harness for interacting with a standard Material inputs in tests. */\nclass MatInputHarness extends MatFormFieldControlHarness {\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatInputHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which input instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatInputHarness, options)\n            .addOption('value', options.value, (harness, value) => {\n            return HarnessPredicate.stringMatches(harness.getValue(), value);\n        })\n            .addOption('placeholder', options.placeholder, (harness, placeholder) => {\n            return HarnessPredicate.stringMatches(harness.getPlaceholder(), placeholder);\n        });\n    }\n    /** Whether the input is disabled. */\n    async isDisabled() {\n        return (await this.host()).getProperty('disabled');\n    }\n    /** Whether the input is required. */\n    async isRequired() {\n        return (await this.host()).getProperty('required');\n    }\n    /** Whether the input is readonly. */\n    async isReadonly() {\n        return (await this.host()).getProperty('readOnly');\n    }\n    /** Gets the value of the input. */\n    async getValue() {\n        // The \"value\" property of the native input is never undefined.\n        return await (await this.host()).getProperty('value');\n    }\n    /** Gets the name of the input. */\n    async getName() {\n        // The \"name\" property of the native input is never undefined.\n        return await (await this.host()).getProperty('name');\n    }\n    /**\n     * Gets the type of the input. Returns \"textarea\" if the input is\n     * a textarea.\n     */\n    async getType() {\n        // The \"type\" property of the native input is never undefined.\n        return await (await this.host()).getProperty('type');\n    }\n    /** Gets the placeholder of the input. */\n    async getPlaceholder() {\n        const host = await this.host();\n        const [nativePlaceholder, fallback] = await parallel(() => [\n            host.getProperty('placeholder'),\n            host.getAttribute('data-placeholder'),\n        ]);\n        return nativePlaceholder || fallback || '';\n    }\n    /** Gets the id of the input. */\n    async getId() {\n        // The input directive always assigns a unique id to the input in\n        // case no id has been explicitly specified.\n        return await (await this.host()).getProperty('id');\n    }\n    /**\n     * Focuses the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    async focus() {\n        return (await this.host()).focus();\n    }\n    /**\n     * Blurs the input and returns a promise that indicates when the\n     * action is complete.\n     */\n    async blur() {\n        return (await this.host()).blur();\n    }\n    /** Whether the input is focused. */\n    async isFocused() {\n        return (await this.host()).isFocused();\n    }\n    /**\n     * Sets the value of the input. The value will be set by simulating\n     * keypresses that correspond to the given value.\n     */\n    async setValue(newValue) {\n        const inputEl = await this.host();\n        await inputEl.clear();\n        // We don't want to send keys for the value if the value is an empty\n        // string in order to clear the value. Sending keys with an empty string\n        // still results in unnecessary focus events.\n        if (newValue) {\n            await inputEl.sendKeys(newValue);\n        }\n        // Some input types won't respond to key presses (e.g. `color`) so to be sure that the\n        // value is set, we also set the property after the keyboard sequence. Note that we don't\n        // want to do it before, because it can cause the value to be entered twice.\n        await inputEl.setInputValue(newValue);\n    }\n}\n// TODO: We do not want to handle `select` elements with `matNativeControl` because\n// not all methods of this harness work reasonably for native select elements.\n// For more details. See: https://github.com/angular/components/pull/18221.\nMatInputHarness.hostSelector = '[matInput], input[matNativeControl], textarea[matNativeControl]';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Harness for interacting with a native `option` in tests. */\nclass MatNativeOptionHarness extends ComponentHarness {\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatNativeOptionHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which option instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatNativeOptionHarness, options)\n            .addOption('text', options.text, async (harness, title) => HarnessPredicate.stringMatches(await harness.getText(), title))\n            .addOption('index', options.index, async (harness, index) => (await harness.getIndex()) === index)\n            .addOption('isSelected', options.isSelected, async (harness, isSelected) => (await harness.isSelected()) === isSelected);\n    }\n    /** Gets the option's label text. */\n    async getText() {\n        return (await this.host()).getProperty('label');\n    }\n    /** Index of the option within the native `select` element. */\n    async getIndex() {\n        return (await this.host()).getProperty('index');\n    }\n    /** Gets whether the option is disabled. */\n    async isDisabled() {\n        return (await this.host()).getProperty('disabled');\n    }\n    /** Gets whether the option is selected. */\n    async isSelected() {\n        return (await this.host()).getProperty('selected');\n    }\n}\n/** Selector used to locate option instances. */\nMatNativeOptionHarness.hostSelector = 'select[matNativeControl] option';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Harness for interacting with a native `select` in tests. */\nclass MatNativeSelectHarness extends MatFormFieldControlHarness {\n    /**\n     * Gets a `HarnessPredicate` that can be used to search for a `MatNativeSelectHarness` that meets\n     * certain criteria.\n     * @param options Options for filtering which select instances are considered a match.\n     * @return a `HarnessPredicate` configured with the given options.\n     */\n    static with(options = {}) {\n        return new HarnessPredicate(MatNativeSelectHarness, options);\n    }\n    /** Gets a boolean promise indicating if the select is disabled. */\n    async isDisabled() {\n        return (await this.host()).getProperty('disabled');\n    }\n    /** Gets a boolean promise indicating if the select is required. */\n    async isRequired() {\n        return (await this.host()).getProperty('required');\n    }\n    /** Gets a boolean promise indicating if the select is in multi-selection mode. */\n    async isMultiple() {\n        return (await this.host()).getProperty('multiple');\n    }\n    /** Gets the name of the select. */\n    async getName() {\n        // The \"name\" property of the native select is never undefined.\n        return await (await this.host()).getProperty('name');\n    }\n    /** Gets the id of the select. */\n    async getId() {\n        // We're guaranteed to have an id, because the `matNativeControl` always assigns one.\n        return await (await this.host()).getProperty('id');\n    }\n    /** Focuses the select and returns a void promise that indicates when the action is complete. */\n    async focus() {\n        return (await this.host()).focus();\n    }\n    /** Blurs the select and returns a void promise that indicates when the action is complete. */\n    async blur() {\n        return (await this.host()).blur();\n    }\n    /** Whether the select is focused. */\n    async isFocused() {\n        return (await this.host()).isFocused();\n    }\n    /** Gets the options inside the select panel. */\n    async getOptions(filter = {}) {\n        return this.locatorForAll(MatNativeOptionHarness.with(filter))();\n    }\n    /**\n     * Selects the options that match the passed-in filter. If the select is in multi-selection\n     * mode all options will be clicked, otherwise the harness will pick the first matching option.\n     */\n    async selectOptions(filter = {}) {\n        const [isMultiple, options] = await parallel(() => {\n            return [this.isMultiple(), this.getOptions(filter)];\n        });\n        if (options.length === 0) {\n            throw Error('Select does not have options matching the specified filter');\n        }\n        const [host, optionIndexes] = await parallel(() => [\n            this.host(),\n            parallel(() => options.slice(0, isMultiple ? undefined : 1).map(option => option.getIndex())),\n        ]);\n        await host.selectOptions(...optionIndexes);\n    }\n}\nMatNativeSelectHarness.hostSelector = 'select[matNativeControl]';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { MatInputHarness, MatNativeOptionHarness, MatNativeSelectHarness };\n"]},"metadata":{},"sourceType":"module"}