{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/toni_/OneDrive/\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B/Diary/Diary/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { BehaviorSubject } from 'rxjs';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Subject used to dispatch and listen for changes to the auto change detection status . */\n\nconst autoChangeDetectionSubject = new BehaviorSubject({\n  isDisabled: false\n});\n/** The current subscription to `autoChangeDetectionSubject`. */\n\nlet autoChangeDetectionSubscription;\n/**\n * The default handler for auto change detection status changes. This handler will be used if the\n * specific environment does not install its own.\n * @param status The new auto change detection status.\n */\n\nfunction defaultAutoChangeDetectionHandler(status) {\n  status.onDetectChangesNow?.();\n}\n/**\n * Allows a test `HarnessEnvironment` to install its own handler for auto change detection status\n * changes.\n * @param handler The handler for the auto change detection status.\n */\n\n\nfunction handleAutoChangeDetectionStatus(handler) {\n  stopHandlingAutoChangeDetectionStatus();\n  autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);\n}\n/** Allows a `HarnessEnvironment` to stop handling auto change detection status changes. */\n\n\nfunction stopHandlingAutoChangeDetectionStatus() {\n  autoChangeDetectionSubscription?.unsubscribe();\n  autoChangeDetectionSubscription = null;\n}\n/**\n * Batches together triggering of change detection over the duration of the given function.\n * @param fn The function to call with batched change detection.\n * @param triggerBeforeAndAfter Optionally trigger change detection once before and after the batch\n *   operation. If false, change detection will not be triggered.\n * @return The result of the given function.\n */\n\n\nfunction batchChangeDetection(_x, _x2) {\n  return _batchChangeDetection.apply(this, arguments);\n}\n/**\n * Disables the harness system's auto change detection for the duration of the given function.\n * @param fn The function to disable auto change detection for.\n * @return The result of the given function.\n */\n\n\nfunction _batchChangeDetection() {\n  _batchChangeDetection = _asyncToGenerator(function* (fn, triggerBeforeAndAfter) {\n    // If change detection batching is already in progress, just run the function.\n    if (autoChangeDetectionSubject.getValue().isDisabled) {\n      return yield fn();\n    } // If nothing is handling change detection batching, install the default handler.\n\n\n    if (!autoChangeDetectionSubscription) {\n      handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);\n    }\n\n    if (triggerBeforeAndAfter) {\n      yield new Promise(resolve => autoChangeDetectionSubject.next({\n        isDisabled: true,\n        onDetectChangesNow: resolve\n      })); // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n      // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n      // we wrap it in a `finally` block.\n\n      try {\n        return yield fn();\n      } finally {\n        yield new Promise(resolve => autoChangeDetectionSubject.next({\n          isDisabled: false,\n          onDetectChangesNow: resolve\n        }));\n      }\n    } else {\n      autoChangeDetectionSubject.next({\n        isDisabled: true\n      }); // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n      // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n      // we wrap it in a `finally` block.\n\n      try {\n        return yield fn();\n      } finally {\n        autoChangeDetectionSubject.next({\n          isDisabled: false\n        });\n      }\n    }\n  });\n  return _batchChangeDetection.apply(this, arguments);\n}\n\nfunction manualChangeDetection(_x3) {\n  return _manualChangeDetection.apply(this, arguments);\n}\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\n\n\nfunction _manualChangeDetection() {\n  _manualChangeDetection = _asyncToGenerator(function* (fn) {\n    return batchChangeDetection(fn, false);\n  });\n  return _manualChangeDetection.apply(this, arguments);\n}\n\nfunction parallel(_x4) {\n  return _parallel.apply(this, arguments);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Base class for component harnesses that all component harness authors should extend. This base\n * component harness provides the basic ability to locate element and sub-component harness. It\n * should be inherited when defining user's own harness.\n */\n\n\nfunction _parallel() {\n  _parallel = _asyncToGenerator(function* (values) {\n    return batchChangeDetection(() => Promise.all(values()), true);\n  });\n  return _parallel.apply(this, arguments);\n}\n\nclass ComponentHarness {\n  constructor(locatorFactory) {\n    this.locatorFactory = locatorFactory;\n  }\n  /** Gets a `Promise` for the `TestElement` representing the host element of the component. */\n\n\n  host() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.locatorFactory.rootElement;\n    })();\n  }\n  /**\n   * Gets a `LocatorFactory` for the document root element. This factory can be used to create\n   * locators for elements that a component creates outside of its own root element. (e.g. by\n   * appending to document.body).\n   */\n\n\n  documentRootLocatorFactory() {\n    return this.locatorFactory.documentRootLocatorFactory();\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n   * or element under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for the\n   *   first element or harness matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If no matches are found, the\n   *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n   *   each query.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'`:\n   * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n   * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n   * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.\n   */\n\n\n  locatorFor(...queries) {\n    return this.locatorFactory.locatorFor(...queries);\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n   * or element under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for the\n   *   first element or harness matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If no matches are found, the\n   *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n   *   result types for each query or null.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'`:\n   * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n   * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n   * - `await ch.locatorForOptional('span')()` gets `null`.\n   */\n\n\n  locatorForOptional(...queries) {\n    return this.locatorFactory.locatorForOptional(...queries);\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n   * or elements under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for all\n   *   elements and harnesses matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If an element matches more than\n   *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n   *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n   *   for that element. The type that the `Promise` resolves to is an array where each element is\n   *   the union of all result types for each query.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n   * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[\n   *     DivHarness, // for #d1\n   *     TestElement, // for #d1\n   *     DivHarness, // for #d2\n   *     TestElement // for #d2\n   *   ]`\n   * - `await ch.locatorForAll('div', '#d1')()` gets `[\n   *     TestElement, // for #d1\n   *     TestElement // for #d2\n   *   ]`\n   * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n   *     DivHarness, // for #d1\n   *     IdIsD1Harness, // for #d1\n   *     DivHarness // for #d2\n   *   ]`\n   * - `await ch.locatorForAll('span')()` gets `[]`.\n   */\n\n\n  locatorForAll(...queries) {\n    return this.locatorFactory.locatorForAll(...queries);\n  }\n  /**\n   * Flushes change detection and async tasks in the Angular zone.\n   * In most cases it should not be necessary to call this manually. However, there may be some edge\n   * cases where it is needed to fully flush animation events.\n   */\n\n\n  forceStabilize() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2.locatorFactory.forceStabilize();\n    })();\n  }\n  /**\n   * Waits for all scheduled or running async tasks to complete. This allows harness\n   * authors to wait for async tasks outside of the Angular zone.\n   */\n\n\n  waitForTasksOutsideAngular() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this3.locatorFactory.waitForTasksOutsideAngular();\n    })();\n  }\n\n}\n/**\n * Base class for component harnesses that authors should extend if they anticipate that consumers\n * of the harness may want to access other harnesses within the `<ng-content>` of the component.\n */\n\n\nclass ContentContainerComponentHarness extends ComponentHarness {\n  getChildLoader(selector) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this4.getRootHarnessLoader()).getChildLoader(selector);\n    })();\n  }\n\n  getAllChildLoaders(selector) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this5.getRootHarnessLoader()).getAllChildLoaders(selector);\n    })();\n  }\n\n  getHarness(query) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this6.getRootHarnessLoader()).getHarness(query);\n    })();\n  }\n\n  getAllHarnesses(query) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this7.getRootHarnessLoader()).getAllHarnesses(query);\n    })();\n  }\n  /**\n   * Gets the root harness loader from which to start\n   * searching for content contained by this harness.\n   */\n\n\n  getRootHarnessLoader() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this8.locatorFactory.rootHarnessLoader();\n    })();\n  }\n\n}\n/**\n * A class used to associate a ComponentHarness class with predicates functions that can be used to\n * filter instances of the class.\n */\n\n\nclass HarnessPredicate {\n  constructor(harnessType, options) {\n    this.harnessType = harnessType;\n    this._predicates = [];\n    this._descriptions = [];\n\n    this._addBaseOptions(options);\n  }\n  /**\n   * Checks if the specified nullable string value matches the given pattern.\n   * @param value The nullable string value to check, or a Promise resolving to the\n   *   nullable string value.\n   * @param pattern The pattern the value is expected to match. If `pattern` is a string,\n   *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is\n   *   allowed. If `pattern` is `null`, the value is expected to be `null`.\n   * @return Whether the value matches the pattern.\n   */\n\n\n  static stringMatches(value, pattern) {\n    return _asyncToGenerator(function* () {\n      value = yield value;\n\n      if (pattern === null) {\n        return value === null;\n      } else if (value === null) {\n        return false;\n      }\n\n      return typeof pattern === 'string' ? value === pattern : pattern.test(value);\n    })();\n  }\n  /**\n   * Adds a predicate function to be run against candidate harnesses.\n   * @param description A description of this predicate that may be used in error messages.\n   * @param predicate An async predicate function.\n   * @return this (for method chaining).\n   */\n\n\n  add(description, predicate) {\n    this._descriptions.push(description);\n\n    this._predicates.push(predicate);\n\n    return this;\n  }\n  /**\n   * Adds a predicate function that depends on an option value to be run against candidate\n   * harnesses. If the option value is undefined, the predicate will be ignored.\n   * @param name The name of the option (may be used in error messages).\n   * @param option The option value.\n   * @param predicate The predicate function to run if the option value is not undefined.\n   * @return this (for method chaining).\n   */\n\n\n  addOption(name, option, predicate) {\n    if (option !== undefined) {\n      this.add(`${name} = ${_valueAsString(option)}`, item => predicate(item, option));\n    }\n\n    return this;\n  }\n  /**\n   * Filters a list of harnesses on this predicate.\n   * @param harnesses The list of harnesses to filter.\n   * @return A list of harnesses that satisfy this predicate.\n   */\n\n\n  filter(harnesses) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      if (harnesses.length === 0) {\n        return [];\n      }\n\n      const results = yield parallel(() => harnesses.map(h => _this9.evaluate(h)));\n      return harnesses.filter((_, i) => results[i]);\n    })();\n  }\n  /**\n   * Evaluates whether the given harness satisfies this predicate.\n   * @param harness The harness to check\n   * @return A promise that resolves to true if the harness satisfies this predicate,\n   *   and resolves to false otherwise.\n   */\n\n\n  evaluate(harness) {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const results = yield parallel(() => _this10._predicates.map(p => p(harness)));\n      return results.reduce((combined, current) => combined && current, true);\n    })();\n  }\n  /** Gets a description of this predicate for use in error messages. */\n\n\n  getDescription() {\n    return this._descriptions.join(', ');\n  }\n  /** Gets the selector used to find candidate elements. */\n\n\n  getSelector() {\n    // We don't have to go through the extra trouble if there are no ancestors.\n    if (!this._ancestor) {\n      return (this.harnessType.hostSelector || '').trim();\n    }\n\n    const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);\n\n    const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || '');\n\n    const result = []; // We have to add the ancestor to each part of the host compound selector, otherwise we can get\n    // incorrect results. E.g. `.ancestor .a, .ancestor .b` vs `.ancestor .a, .b`.\n\n    ancestors.forEach(escapedAncestor => {\n      const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);\n\n      return selectors.forEach(escapedSelector => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));\n    });\n    return result.join(', ');\n  }\n  /** Adds base options common to all harness types. */\n\n\n  _addBaseOptions(options) {\n    this._ancestor = options.ancestor || '';\n\n    if (this._ancestor) {\n      this._descriptions.push(`has ancestor matching selector \"${this._ancestor}\"`);\n    }\n\n    const selector = options.selector;\n\n    if (selector !== undefined) {\n      this.add(`host matches selector \"${selector}\"`, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (item) {\n          return (yield item.host()).matchesSelector(selector);\n        });\n\n        return function (_x5) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }\n\n}\n/** Represent a value as a string for the purpose of logging. */\n\n\nfunction _valueAsString(value) {\n  if (value === undefined) {\n    return 'undefined';\n  }\n\n  try {\n    // `JSON.stringify` doesn't handle RegExp properly, so we need a custom replacer.\n    // Use a character that is unlikely to appear in real strings to denote the start and end of\n    // the regex. This allows us to strip out the extra quotes around the value added by\n    // `JSON.stringify`. Also do custom escaping on `\"` characters to prevent `JSON.stringify`\n    // from escaping them as if they were part of a string.\n    const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp ? `◬MAT_RE_ESCAPE◬${v.toString().replace(/\"/g, '◬MAT_RE_ESCAPE◬')}◬MAT_RE_ESCAPE◬` : v); // Strip out the extra quotes around regexes and put back the manually escaped `\"` characters.\n\n    return stringifiedValue.replace(/\"◬MAT_RE_ESCAPE◬|◬MAT_RE_ESCAPE◬\"/g, '').replace(/◬MAT_RE_ESCAPE◬/g, '\"');\n  } catch {\n    // `JSON.stringify` will throw if the object is cyclical,\n    // in this case the best we can do is report the value as `{...}`.\n    return '{...}';\n  }\n}\n/**\n * Splits up a compound selector into its parts and escapes any quoted content. The quoted content\n * has to be escaped, because it can contain commas which will throw throw us off when trying to\n * split it.\n * @param selector Selector to be split.\n * @returns The escaped string where any quoted content is replaced with a placeholder. E.g.\n * `[foo=\"bar\"]` turns into `[foo=__cdkPlaceholder-0__]`. Use `_restoreSelector` to restore\n * the placeholders.\n */\n\n\nfunction _splitAndEscapeSelector(selector) {\n  const placeholders = []; // Note that the regex doesn't account for nested quotes so something like `\"ab'cd'e\"` will be\n  // considered as two blocks. It's a bit of an edge case, but if we find that it's a problem,\n  // we can make it a bit smarter using a loop. Use this for now since it's more readable and\n  // compact. More complete implementation:\n  // https://github.com/angular/angular/blob/bd34bc9e89f18a/packages/compiler/src/shadow_css.ts#L655\n\n  const result = selector.replace(/([\"'][^[\"']*[\"'])/g, (_, keep) => {\n    const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;\n    placeholders.push(keep);\n    return replaceBy;\n  });\n  return [result.split(',').map(part => part.trim()), placeholders];\n}\n/** Restores a selector whose content was escaped in `_splitAndEscapeSelector`. */\n\n\nfunction _restoreSelector(selector, placeholders) {\n  return selector.replace(/__cdkPlaceholder-(\\d+)__/g, (_, index) => placeholders[+index]);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Base harness environment class that can be extended to allow `ComponentHarness`es to be used in\n * different test environments (e.g. testbed, protractor, etc.). This class implements the\n * functionality of both a `HarnessLoader` and `LocatorFactory`. This class is generic on the raw\n * element type, `E`, used by the particular test environment.\n */\n\n\nclass HarnessEnvironment {\n  constructor(rawRootElement) {\n    this.rawRootElement = rawRootElement;\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  get rootElement() {\n    this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);\n    return this._rootElement;\n  }\n\n  set rootElement(element) {\n    this._rootElement = element;\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  documentRootLocatorFactory() {\n    return this.createEnvironment(this.getDocumentRoot());\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  locatorFor(...queries) {\n    return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  locatorForOptional(...queries) {\n    var _this11 = this;\n\n    return /*#__PURE__*/_asyncToGenerator(function* () {\n      return (yield _this11._getAllHarnessesAndTestElements(queries))[0] || null;\n    });\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  locatorForAll(...queries) {\n    return () => this._getAllHarnessesAndTestElements(queries);\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  rootHarnessLoader() {\n    var _this12 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this12;\n    })();\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  harnessLoaderFor(selector) {\n    var _this13 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this13.createEnvironment(yield _assertResultFound(_this13.getAllRawElements(selector), [_getDescriptionForHarnessLoaderQuery(selector)]));\n    })();\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  harnessLoaderForOptional(selector) {\n    var _this14 = this;\n\n    return _asyncToGenerator(function* () {\n      const elements = yield _this14.getAllRawElements(selector);\n      return elements[0] ? _this14.createEnvironment(elements[0]) : null;\n    })();\n  } // Implemented as part of the `LocatorFactory` interface.\n\n\n  harnessLoaderForAll(selector) {\n    var _this15 = this;\n\n    return _asyncToGenerator(function* () {\n      const elements = yield _this15.getAllRawElements(selector);\n      return elements.map(element => _this15.createEnvironment(element));\n    })();\n  } // Implemented as part of the `HarnessLoader` interface.\n\n\n  getHarness(query) {\n    return this.locatorFor(query)();\n  } // Implemented as part of the `HarnessLoader` interface.\n\n\n  getAllHarnesses(query) {\n    return this.locatorForAll(query)();\n  } // Implemented as part of the `HarnessLoader` interface.\n\n\n  getChildLoader(selector) {\n    var _this16 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this16.createEnvironment(yield _assertResultFound(_this16.getAllRawElements(selector), [_getDescriptionForHarnessLoaderQuery(selector)]));\n    })();\n  } // Implemented as part of the `HarnessLoader` interface.\n\n\n  getAllChildLoaders(selector) {\n    var _this17 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this17.getAllRawElements(selector)).map(e => _this17.createEnvironment(e));\n    })();\n  }\n  /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */\n\n\n  createComponentHarness(harnessType, element) {\n    return new harnessType(this.createEnvironment(element));\n  }\n  /**\n   * Matches the given raw elements with the given list of element and harness queries to produce a\n   * list of matched harnesses and test elements.\n   */\n\n\n  _getAllHarnessesAndTestElements(queries) {\n    var _this18 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!queries.length) {\n        throw Error('CDK Component harness query must contain at least one element.');\n      }\n\n      const {\n        allQueries,\n        harnessQueries,\n        elementQueries,\n        harnessTypes\n      } = _parseQueries(queries); // Combine all of the queries into one large comma-delimited selector and use it to get all raw\n      // elements matching any of the individual queries.\n\n\n      const rawElements = yield _this18.getAllRawElements([...elementQueries, ...harnessQueries.map(predicate => predicate.getSelector())].join(',')); // If every query is searching for the same harness subclass, we know every result corresponds\n      // to an instance of that subclass. Likewise, if every query is for a `TestElement`, we know\n      // every result corresponds to a `TestElement`. Otherwise we need to verify which result was\n      // found by which selector so it can be matched to the appropriate instance.\n\n      const skipSelectorCheck = elementQueries.length === 0 && harnessTypes.size === 1 || harnessQueries.length === 0;\n      const perElementMatches = yield parallel(() => rawElements.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (rawElement) {\n          const testElement = _this18.createTestElement(rawElement);\n\n          const allResultsForElement = yield parallel( // For each query, get `null` if it doesn't match, or a `TestElement` or\n          // `ComponentHarness` as appropriate if it does match. This gives us everything that\n          // matches the current raw element, but it may contain duplicate entries (e.g.\n          // multiple `TestElement` or multiple `ComponentHarness` of the same type).\n          () => allQueries.map(query => _this18._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck)));\n          return _removeDuplicateQueryResults(allResultsForElement);\n        });\n\n        return function (_x6) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return [].concat(...perElementMatches);\n    })();\n  }\n  /**\n   * Check whether the given query matches the given element, if it does return the matched\n   * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller\n   * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used\n   * to skip verification and optimize performance.\n   */\n\n\n  _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {\n    var _this19 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof query === 'string') {\n        return skipSelectorCheck || (yield testElement.matchesSelector(query)) ? testElement : null;\n      }\n\n      if (skipSelectorCheck || (yield testElement.matchesSelector(query.getSelector()))) {\n        const harness = _this19.createComponentHarness(query.harnessType, rawElement);\n\n        return (yield query.evaluate(harness)) ? harness : null;\n      }\n\n      return null;\n    })();\n  }\n\n}\n/**\n * Parses a list of queries in the format accepted by the `locatorFor*` methods into an easier to\n * work with format.\n */\n\n\nfunction _parseQueries(queries) {\n  const allQueries = [];\n  const harnessQueries = [];\n  const elementQueries = [];\n  const harnessTypes = new Set();\n\n  for (const query of queries) {\n    if (typeof query === 'string') {\n      allQueries.push(query);\n      elementQueries.push(query);\n    } else {\n      const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n      allQueries.push(predicate);\n      harnessQueries.push(predicate);\n      harnessTypes.add(predicate.harnessType);\n    }\n  }\n\n  return {\n    allQueries,\n    harnessQueries,\n    elementQueries,\n    harnessTypes\n  };\n}\n/**\n * Removes duplicate query results for a particular element. (e.g. multiple `TestElement`\n * instances or multiple instances of the same `ComponentHarness` class.\n */\n\n\nfunction _removeDuplicateQueryResults(_x7) {\n  return _removeDuplicateQueryResults2.apply(this, arguments);\n}\n/** Verifies that there is at least one result in an array. */\n\n\nfunction _removeDuplicateQueryResults2() {\n  _removeDuplicateQueryResults2 = _asyncToGenerator(function* (results) {\n    let testElementMatched = false;\n    let matchedHarnessTypes = new Set();\n    const dedupedMatches = [];\n\n    for (const result of results) {\n      if (!result) {\n        continue;\n      }\n\n      if (result instanceof ComponentHarness) {\n        if (!matchedHarnessTypes.has(result.constructor)) {\n          matchedHarnessTypes.add(result.constructor);\n          dedupedMatches.push(result);\n        }\n      } else if (!testElementMatched) {\n        testElementMatched = true;\n        dedupedMatches.push(result);\n      }\n    }\n\n    return dedupedMatches;\n  });\n  return _removeDuplicateQueryResults2.apply(this, arguments);\n}\n\nfunction _assertResultFound(_x8, _x9) {\n  return _assertResultFound2.apply(this, arguments);\n}\n/** Gets a list of description strings from a list of queries. */\n\n\nfunction _assertResultFound2() {\n  _assertResultFound2 = _asyncToGenerator(function* (results, queryDescriptions) {\n    const result = (yield results)[0];\n\n    if (result == undefined) {\n      throw Error(`Failed to find element matching one of the following queries:\\n` + queryDescriptions.map(desc => `(${desc})`).join(',\\n'));\n    }\n\n    return result;\n  });\n  return _assertResultFound2.apply(this, arguments);\n}\n\nfunction _getDescriptionForLocatorForQueries(queries) {\n  return queries.map(query => typeof query === 'string' ? _getDescriptionForTestElementQuery(query) : _getDescriptionForComponentHarnessQuery(query));\n}\n/** Gets a description string for a `ComponentHarness` query. */\n\n\nfunction _getDescriptionForComponentHarnessQuery(query) {\n  const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n  const {\n    name,\n    hostSelector\n  } = harnessPredicate.harnessType;\n  const description = `${name} with host element matching selector: \"${hostSelector}\"`;\n  const constraints = harnessPredicate.getDescription();\n  return description + (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : '');\n}\n/** Gets a description string for a `TestElement` query. */\n\n\nfunction _getDescriptionForTestElementQuery(selector) {\n  return `TestElement for element matching selector: \"${selector}\"`;\n}\n/** Gets a description string for a `HarnessLoader` query. */\n\n\nfunction _getDescriptionForHarnessLoaderQuery(selector) {\n  return `HarnessLoader for element matching selector: \"${selector}\"`;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** An enum of non-text keys that can be used with the `sendKeys` method. */\n// NOTE: This is a separate enum from `@angular/cdk/keycodes` because we don't necessarily want to\n// support every possible keyCode. We also can't rely on Protractor's `Key` because we don't want a\n// dependency on any particular testing framework here. Instead we'll just maintain this supported\n// list of keys and let individual concrete `HarnessEnvironment` classes map them to whatever key\n// representation is used in its respective testing framework.\n// tslint:disable-next-line:prefer-const-enum Seems like this causes some issues with System.js\n\n\nvar TestKey;\n\n(function (TestKey) {\n  TestKey[TestKey[\"BACKSPACE\"] = 0] = \"BACKSPACE\";\n  TestKey[TestKey[\"TAB\"] = 1] = \"TAB\";\n  TestKey[TestKey[\"ENTER\"] = 2] = \"ENTER\";\n  TestKey[TestKey[\"SHIFT\"] = 3] = \"SHIFT\";\n  TestKey[TestKey[\"CONTROL\"] = 4] = \"CONTROL\";\n  TestKey[TestKey[\"ALT\"] = 5] = \"ALT\";\n  TestKey[TestKey[\"ESCAPE\"] = 6] = \"ESCAPE\";\n  TestKey[TestKey[\"PAGE_UP\"] = 7] = \"PAGE_UP\";\n  TestKey[TestKey[\"PAGE_DOWN\"] = 8] = \"PAGE_DOWN\";\n  TestKey[TestKey[\"END\"] = 9] = \"END\";\n  TestKey[TestKey[\"HOME\"] = 10] = \"HOME\";\n  TestKey[TestKey[\"LEFT_ARROW\"] = 11] = \"LEFT_ARROW\";\n  TestKey[TestKey[\"UP_ARROW\"] = 12] = \"UP_ARROW\";\n  TestKey[TestKey[\"RIGHT_ARROW\"] = 13] = \"RIGHT_ARROW\";\n  TestKey[TestKey[\"DOWN_ARROW\"] = 14] = \"DOWN_ARROW\";\n  TestKey[TestKey[\"INSERT\"] = 15] = \"INSERT\";\n  TestKey[TestKey[\"DELETE\"] = 16] = \"DELETE\";\n  TestKey[TestKey[\"F1\"] = 17] = \"F1\";\n  TestKey[TestKey[\"F2\"] = 18] = \"F2\";\n  TestKey[TestKey[\"F3\"] = 19] = \"F3\";\n  TestKey[TestKey[\"F4\"] = 20] = \"F4\";\n  TestKey[TestKey[\"F5\"] = 21] = \"F5\";\n  TestKey[TestKey[\"F6\"] = 22] = \"F6\";\n  TestKey[TestKey[\"F7\"] = 23] = \"F7\";\n  TestKey[TestKey[\"F8\"] = 24] = \"F8\";\n  TestKey[TestKey[\"F9\"] = 25] = \"F9\";\n  TestKey[TestKey[\"F10\"] = 26] = \"F10\";\n  TestKey[TestKey[\"F11\"] = 27] = \"F11\";\n  TestKey[TestKey[\"F12\"] = 28] = \"F12\";\n  TestKey[TestKey[\"META\"] = 29] = \"META\";\n})(TestKey || (TestKey = {}));\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Returns an error which reports that no keys have been specified.\n * @docs-private\n */\n\n\nfunction getNoKeysSpecifiedError() {\n  return Error('No keys have been specified.');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Gets text of element excluding certain selectors within the element.\n * @param element Element to get text from,\n * @param excludeSelector Selector identifying which elements to exclude,\n */\n\n\nfunction _getTextWithExcludedElements(element, excludeSelector) {\n  const clone = element.cloneNode(true);\n  const exclusions = clone.querySelectorAll(excludeSelector);\n\n  for (let i = 0; i < exclusions.length; i++) {\n    exclusions[i].remove();\n  }\n\n  return (clone.textContent || '').trim();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nexport { ComponentHarness, ContentContainerComponentHarness, HarnessEnvironment, HarnessPredicate, TestKey, _getTextWithExcludedElements, getNoKeysSpecifiedError, handleAutoChangeDetectionStatus, manualChangeDetection, parallel, stopHandlingAutoChangeDetectionStatus };","map":{"version":3,"sources":["C:/Users/toni_/OneDrive/Рабочий стол/Diary/Diary/ClientApp/node_modules/@angular/cdk/fesm2020/testing.mjs"],"names":["BehaviorSubject","autoChangeDetectionSubject","isDisabled","autoChangeDetectionSubscription","defaultAutoChangeDetectionHandler","status","onDetectChangesNow","handleAutoChangeDetectionStatus","handler","stopHandlingAutoChangeDetectionStatus","subscribe","unsubscribe","batchChangeDetection","fn","triggerBeforeAndAfter","getValue","Promise","resolve","next","manualChangeDetection","parallel","values","all","ComponentHarness","constructor","locatorFactory","host","rootElement","documentRootLocatorFactory","locatorFor","queries","locatorForOptional","locatorForAll","forceStabilize","waitForTasksOutsideAngular","ContentContainerComponentHarness","getChildLoader","selector","getRootHarnessLoader","getAllChildLoaders","getHarness","query","getAllHarnesses","rootHarnessLoader","HarnessPredicate","harnessType","options","_predicates","_descriptions","_addBaseOptions","stringMatches","value","pattern","test","add","description","predicate","push","addOption","name","option","undefined","_valueAsString","item","filter","harnesses","length","results","map","h","evaluate","_","i","harness","p","reduce","combined","current","getDescription","join","getSelector","_ancestor","hostSelector","trim","ancestors","ancestorPlaceholders","_splitAndEscapeSelector","selectors","selectorPlaceholders","result","forEach","escapedAncestor","ancestor","_restoreSelector","escapedSelector","matchesSelector","stringifiedValue","JSON","stringify","v","RegExp","toString","replace","placeholders","keep","replaceBy","split","part","index","HarnessEnvironment","rawRootElement","_rootElement","createTestElement","element","createEnvironment","getDocumentRoot","_assertResultFound","_getAllHarnessesAndTestElements","_getDescriptionForLocatorForQueries","harnessLoaderFor","getAllRawElements","_getDescriptionForHarnessLoaderQuery","harnessLoaderForOptional","elements","harnessLoaderForAll","e","createComponentHarness","Error","allQueries","harnessQueries","elementQueries","harnessTypes","_parseQueries","rawElements","skipSelectorCheck","size","perElementMatches","rawElement","testElement","allResultsForElement","_getQueryResultForElement","_removeDuplicateQueryResults","concat","Set","testElementMatched","matchedHarnessTypes","dedupedMatches","has","queryDescriptions","desc","_getDescriptionForTestElementQuery","_getDescriptionForComponentHarnessQuery","harnessPredicate","constraints","TestKey","getNoKeysSpecifiedError","_getTextWithExcludedElements","excludeSelector","clone","cloneNode","exclusions","querySelectorAll","remove","textContent"],"mappings":"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","sourcesContent":["import { BehaviorSubject } from 'rxjs';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Subject used to dispatch and listen for changes to the auto change detection status . */\nconst autoChangeDetectionSubject = new BehaviorSubject({\n    isDisabled: false,\n});\n/** The current subscription to `autoChangeDetectionSubject`. */\nlet autoChangeDetectionSubscription;\n/**\n * The default handler for auto change detection status changes. This handler will be used if the\n * specific environment does not install its own.\n * @param status The new auto change detection status.\n */\nfunction defaultAutoChangeDetectionHandler(status) {\n    status.onDetectChangesNow?.();\n}\n/**\n * Allows a test `HarnessEnvironment` to install its own handler for auto change detection status\n * changes.\n * @param handler The handler for the auto change detection status.\n */\nfunction handleAutoChangeDetectionStatus(handler) {\n    stopHandlingAutoChangeDetectionStatus();\n    autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);\n}\n/** Allows a `HarnessEnvironment` to stop handling auto change detection status changes. */\nfunction stopHandlingAutoChangeDetectionStatus() {\n    autoChangeDetectionSubscription?.unsubscribe();\n    autoChangeDetectionSubscription = null;\n}\n/**\n * Batches together triggering of change detection over the duration of the given function.\n * @param fn The function to call with batched change detection.\n * @param triggerBeforeAndAfter Optionally trigger change detection once before and after the batch\n *   operation. If false, change detection will not be triggered.\n * @return The result of the given function.\n */\nasync function batchChangeDetection(fn, triggerBeforeAndAfter) {\n    // If change detection batching is already in progress, just run the function.\n    if (autoChangeDetectionSubject.getValue().isDisabled) {\n        return await fn();\n    }\n    // If nothing is handling change detection batching, install the default handler.\n    if (!autoChangeDetectionSubscription) {\n        handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);\n    }\n    if (triggerBeforeAndAfter) {\n        await new Promise(resolve => autoChangeDetectionSubject.next({\n            isDisabled: true,\n            onDetectChangesNow: resolve,\n        }));\n        // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n        // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n        // we wrap it in a `finally` block.\n        try {\n            return await fn();\n        }\n        finally {\n            await new Promise(resolve => autoChangeDetectionSubject.next({\n                isDisabled: false,\n                onDetectChangesNow: resolve,\n            }));\n        }\n    }\n    else {\n        autoChangeDetectionSubject.next({ isDisabled: true });\n        // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n        // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n        // we wrap it in a `finally` block.\n        try {\n            return await fn();\n        }\n        finally {\n            autoChangeDetectionSubject.next({ isDisabled: false });\n        }\n    }\n}\n/**\n * Disables the harness system's auto change detection for the duration of the given function.\n * @param fn The function to disable auto change detection for.\n * @return The result of the given function.\n */\nasync function manualChangeDetection(fn) {\n    return batchChangeDetection(fn, false);\n}\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nasync function parallel(values) {\n    return batchChangeDetection(() => Promise.all(values()), true);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base class for component harnesses that all component harness authors should extend. This base\n * component harness provides the basic ability to locate element and sub-component harness. It\n * should be inherited when defining user's own harness.\n */\nclass ComponentHarness {\n    constructor(locatorFactory) {\n        this.locatorFactory = locatorFactory;\n    }\n    /** Gets a `Promise` for the `TestElement` representing the host element of the component. */\n    async host() {\n        return this.locatorFactory.rootElement;\n    }\n    /**\n     * Gets a `LocatorFactory` for the document root element. This factory can be used to create\n     * locators for elements that a component creates outside of its own root element. (e.g. by\n     * appending to document.body).\n     */\n    documentRootLocatorFactory() {\n        return this.locatorFactory.documentRootLocatorFactory();\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n     *   each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.\n     */\n    locatorFor(...queries) {\n        return this.locatorFactory.locatorFor(...queries);\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n     *   result types for each query or null.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorForOptional('span')()` gets `null`.\n     */\n    locatorForOptional(...queries) {\n        return this.locatorFactory.locatorForOptional(...queries);\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n     * or elements under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for all\n     *   elements and harnesses matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If an element matches more than\n     *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n     *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n     *   for that element. The type that the `Promise` resolves to is an array where each element is\n     *   the union of all result types for each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n     * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[\n     *     DivHarness, // for #d1\n     *     TestElement, // for #d1\n     *     DivHarness, // for #d2\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('div', '#d1')()` gets `[\n     *     TestElement, // for #d1\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n     *     DivHarness, // for #d1\n     *     IdIsD1Harness, // for #d1\n     *     DivHarness // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('span')()` gets `[]`.\n     */\n    locatorForAll(...queries) {\n        return this.locatorFactory.locatorForAll(...queries);\n    }\n    /**\n     * Flushes change detection and async tasks in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    async forceStabilize() {\n        return this.locatorFactory.forceStabilize();\n    }\n    /**\n     * Waits for all scheduled or running async tasks to complete. This allows harness\n     * authors to wait for async tasks outside of the Angular zone.\n     */\n    async waitForTasksOutsideAngular() {\n        return this.locatorFactory.waitForTasksOutsideAngular();\n    }\n}\n/**\n * Base class for component harnesses that authors should extend if they anticipate that consumers\n * of the harness may want to access other harnesses within the `<ng-content>` of the component.\n */\nclass ContentContainerComponentHarness extends ComponentHarness {\n    async getChildLoader(selector) {\n        return (await this.getRootHarnessLoader()).getChildLoader(selector);\n    }\n    async getAllChildLoaders(selector) {\n        return (await this.getRootHarnessLoader()).getAllChildLoaders(selector);\n    }\n    async getHarness(query) {\n        return (await this.getRootHarnessLoader()).getHarness(query);\n    }\n    async getAllHarnesses(query) {\n        return (await this.getRootHarnessLoader()).getAllHarnesses(query);\n    }\n    /**\n     * Gets the root harness loader from which to start\n     * searching for content contained by this harness.\n     */\n    async getRootHarnessLoader() {\n        return this.locatorFactory.rootHarnessLoader();\n    }\n}\n/**\n * A class used to associate a ComponentHarness class with predicates functions that can be used to\n * filter instances of the class.\n */\nclass HarnessPredicate {\n    constructor(harnessType, options) {\n        this.harnessType = harnessType;\n        this._predicates = [];\n        this._descriptions = [];\n        this._addBaseOptions(options);\n    }\n    /**\n     * Checks if the specified nullable string value matches the given pattern.\n     * @param value The nullable string value to check, or a Promise resolving to the\n     *   nullable string value.\n     * @param pattern The pattern the value is expected to match. If `pattern` is a string,\n     *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is\n     *   allowed. If `pattern` is `null`, the value is expected to be `null`.\n     * @return Whether the value matches the pattern.\n     */\n    static async stringMatches(value, pattern) {\n        value = await value;\n        if (pattern === null) {\n            return value === null;\n        }\n        else if (value === null) {\n            return false;\n        }\n        return typeof pattern === 'string' ? value === pattern : pattern.test(value);\n    }\n    /**\n     * Adds a predicate function to be run against candidate harnesses.\n     * @param description A description of this predicate that may be used in error messages.\n     * @param predicate An async predicate function.\n     * @return this (for method chaining).\n     */\n    add(description, predicate) {\n        this._descriptions.push(description);\n        this._predicates.push(predicate);\n        return this;\n    }\n    /**\n     * Adds a predicate function that depends on an option value to be run against candidate\n     * harnesses. If the option value is undefined, the predicate will be ignored.\n     * @param name The name of the option (may be used in error messages).\n     * @param option The option value.\n     * @param predicate The predicate function to run if the option value is not undefined.\n     * @return this (for method chaining).\n     */\n    addOption(name, option, predicate) {\n        if (option !== undefined) {\n            this.add(`${name} = ${_valueAsString(option)}`, item => predicate(item, option));\n        }\n        return this;\n    }\n    /**\n     * Filters a list of harnesses on this predicate.\n     * @param harnesses The list of harnesses to filter.\n     * @return A list of harnesses that satisfy this predicate.\n     */\n    async filter(harnesses) {\n        if (harnesses.length === 0) {\n            return [];\n        }\n        const results = await parallel(() => harnesses.map(h => this.evaluate(h)));\n        return harnesses.filter((_, i) => results[i]);\n    }\n    /**\n     * Evaluates whether the given harness satisfies this predicate.\n     * @param harness The harness to check\n     * @return A promise that resolves to true if the harness satisfies this predicate,\n     *   and resolves to false otherwise.\n     */\n    async evaluate(harness) {\n        const results = await parallel(() => this._predicates.map(p => p(harness)));\n        return results.reduce((combined, current) => combined && current, true);\n    }\n    /** Gets a description of this predicate for use in error messages. */\n    getDescription() {\n        return this._descriptions.join(', ');\n    }\n    /** Gets the selector used to find candidate elements. */\n    getSelector() {\n        // We don't have to go through the extra trouble if there are no ancestors.\n        if (!this._ancestor) {\n            return (this.harnessType.hostSelector || '').trim();\n        }\n        const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);\n        const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || '');\n        const result = [];\n        // We have to add the ancestor to each part of the host compound selector, otherwise we can get\n        // incorrect results. E.g. `.ancestor .a, .ancestor .b` vs `.ancestor .a, .b`.\n        ancestors.forEach(escapedAncestor => {\n            const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);\n            return selectors.forEach(escapedSelector => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));\n        });\n        return result.join(', ');\n    }\n    /** Adds base options common to all harness types. */\n    _addBaseOptions(options) {\n        this._ancestor = options.ancestor || '';\n        if (this._ancestor) {\n            this._descriptions.push(`has ancestor matching selector \"${this._ancestor}\"`);\n        }\n        const selector = options.selector;\n        if (selector !== undefined) {\n            this.add(`host matches selector \"${selector}\"`, async (item) => {\n                return (await item.host()).matchesSelector(selector);\n            });\n        }\n    }\n}\n/** Represent a value as a string for the purpose of logging. */\nfunction _valueAsString(value) {\n    if (value === undefined) {\n        return 'undefined';\n    }\n    try {\n        // `JSON.stringify` doesn't handle RegExp properly, so we need a custom replacer.\n        // Use a character that is unlikely to appear in real strings to denote the start and end of\n        // the regex. This allows us to strip out the extra quotes around the value added by\n        // `JSON.stringify`. Also do custom escaping on `\"` characters to prevent `JSON.stringify`\n        // from escaping them as if they were part of a string.\n        const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp\n            ? `◬MAT_RE_ESCAPE◬${v.toString().replace(/\"/g, '◬MAT_RE_ESCAPE◬')}◬MAT_RE_ESCAPE◬`\n            : v);\n        // Strip out the extra quotes around regexes and put back the manually escaped `\"` characters.\n        return stringifiedValue\n            .replace(/\"◬MAT_RE_ESCAPE◬|◬MAT_RE_ESCAPE◬\"/g, '')\n            .replace(/◬MAT_RE_ESCAPE◬/g, '\"');\n    }\n    catch {\n        // `JSON.stringify` will throw if the object is cyclical,\n        // in this case the best we can do is report the value as `{...}`.\n        return '{...}';\n    }\n}\n/**\n * Splits up a compound selector into its parts and escapes any quoted content. The quoted content\n * has to be escaped, because it can contain commas which will throw throw us off when trying to\n * split it.\n * @param selector Selector to be split.\n * @returns The escaped string where any quoted content is replaced with a placeholder. E.g.\n * `[foo=\"bar\"]` turns into `[foo=__cdkPlaceholder-0__]`. Use `_restoreSelector` to restore\n * the placeholders.\n */\nfunction _splitAndEscapeSelector(selector) {\n    const placeholders = [];\n    // Note that the regex doesn't account for nested quotes so something like `\"ab'cd'e\"` will be\n    // considered as two blocks. It's a bit of an edge case, but if we find that it's a problem,\n    // we can make it a bit smarter using a loop. Use this for now since it's more readable and\n    // compact. More complete implementation:\n    // https://github.com/angular/angular/blob/bd34bc9e89f18a/packages/compiler/src/shadow_css.ts#L655\n    const result = selector.replace(/([\"'][^[\"']*[\"'])/g, (_, keep) => {\n        const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;\n        placeholders.push(keep);\n        return replaceBy;\n    });\n    return [result.split(',').map(part => part.trim()), placeholders];\n}\n/** Restores a selector whose content was escaped in `_splitAndEscapeSelector`. */\nfunction _restoreSelector(selector, placeholders) {\n    return selector.replace(/__cdkPlaceholder-(\\d+)__/g, (_, index) => placeholders[+index]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base harness environment class that can be extended to allow `ComponentHarness`es to be used in\n * different test environments (e.g. testbed, protractor, etc.). This class implements the\n * functionality of both a `HarnessLoader` and `LocatorFactory`. This class is generic on the raw\n * element type, `E`, used by the particular test environment.\n */\nclass HarnessEnvironment {\n    constructor(rawRootElement) {\n        this.rawRootElement = rawRootElement;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    get rootElement() {\n        this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);\n        return this._rootElement;\n    }\n    set rootElement(element) {\n        this._rootElement = element;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    documentRootLocatorFactory() {\n        return this.createEnvironment(this.getDocumentRoot());\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorFor(...queries) {\n        return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorForOptional(...queries) {\n        return async () => (await this._getAllHarnessesAndTestElements(queries))[0] || null;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorForAll(...queries) {\n        return () => this._getAllHarnessesAndTestElements(queries);\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async rootHarnessLoader() {\n        return this;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderFor(selector) {\n        return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [\n            _getDescriptionForHarnessLoaderQuery(selector),\n        ]));\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderForOptional(selector) {\n        const elements = await this.getAllRawElements(selector);\n        return elements[0] ? this.createEnvironment(elements[0]) : null;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderForAll(selector) {\n        const elements = await this.getAllRawElements(selector);\n        return elements.map(element => this.createEnvironment(element));\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getHarness(query) {\n        return this.locatorFor(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getAllHarnesses(query) {\n        return this.locatorForAll(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async getChildLoader(selector) {\n        return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [\n            _getDescriptionForHarnessLoaderQuery(selector),\n        ]));\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async getAllChildLoaders(selector) {\n        return (await this.getAllRawElements(selector)).map(e => this.createEnvironment(e));\n    }\n    /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */\n    createComponentHarness(harnessType, element) {\n        return new harnessType(this.createEnvironment(element));\n    }\n    /**\n     * Matches the given raw elements with the given list of element and harness queries to produce a\n     * list of matched harnesses and test elements.\n     */\n    async _getAllHarnessesAndTestElements(queries) {\n        if (!queries.length) {\n            throw Error('CDK Component harness query must contain at least one element.');\n        }\n        const { allQueries, harnessQueries, elementQueries, harnessTypes } = _parseQueries(queries);\n        // Combine all of the queries into one large comma-delimited selector and use it to get all raw\n        // elements matching any of the individual queries.\n        const rawElements = await this.getAllRawElements([...elementQueries, ...harnessQueries.map(predicate => predicate.getSelector())].join(','));\n        // If every query is searching for the same harness subclass, we know every result corresponds\n        // to an instance of that subclass. Likewise, if every query is for a `TestElement`, we know\n        // every result corresponds to a `TestElement`. Otherwise we need to verify which result was\n        // found by which selector so it can be matched to the appropriate instance.\n        const skipSelectorCheck = (elementQueries.length === 0 && harnessTypes.size === 1) || harnessQueries.length === 0;\n        const perElementMatches = await parallel(() => rawElements.map(async (rawElement) => {\n            const testElement = this.createTestElement(rawElement);\n            const allResultsForElement = await parallel(\n            // For each query, get `null` if it doesn't match, or a `TestElement` or\n            // `ComponentHarness` as appropriate if it does match. This gives us everything that\n            // matches the current raw element, but it may contain duplicate entries (e.g.\n            // multiple `TestElement` or multiple `ComponentHarness` of the same type).\n            () => allQueries.map(query => this._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck)));\n            return _removeDuplicateQueryResults(allResultsForElement);\n        }));\n        return [].concat(...perElementMatches);\n    }\n    /**\n     * Check whether the given query matches the given element, if it does return the matched\n     * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller\n     * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used\n     * to skip verification and optimize performance.\n     */\n    async _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {\n        if (typeof query === 'string') {\n            return skipSelectorCheck || (await testElement.matchesSelector(query)) ? testElement : null;\n        }\n        if (skipSelectorCheck || (await testElement.matchesSelector(query.getSelector()))) {\n            const harness = this.createComponentHarness(query.harnessType, rawElement);\n            return (await query.evaluate(harness)) ? harness : null;\n        }\n        return null;\n    }\n}\n/**\n * Parses a list of queries in the format accepted by the `locatorFor*` methods into an easier to\n * work with format.\n */\nfunction _parseQueries(queries) {\n    const allQueries = [];\n    const harnessQueries = [];\n    const elementQueries = [];\n    const harnessTypes = new Set();\n    for (const query of queries) {\n        if (typeof query === 'string') {\n            allQueries.push(query);\n            elementQueries.push(query);\n        }\n        else {\n            const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n            allQueries.push(predicate);\n            harnessQueries.push(predicate);\n            harnessTypes.add(predicate.harnessType);\n        }\n    }\n    return { allQueries, harnessQueries, elementQueries, harnessTypes };\n}\n/**\n * Removes duplicate query results for a particular element. (e.g. multiple `TestElement`\n * instances or multiple instances of the same `ComponentHarness` class.\n */\nasync function _removeDuplicateQueryResults(results) {\n    let testElementMatched = false;\n    let matchedHarnessTypes = new Set();\n    const dedupedMatches = [];\n    for (const result of results) {\n        if (!result) {\n            continue;\n        }\n        if (result instanceof ComponentHarness) {\n            if (!matchedHarnessTypes.has(result.constructor)) {\n                matchedHarnessTypes.add(result.constructor);\n                dedupedMatches.push(result);\n            }\n        }\n        else if (!testElementMatched) {\n            testElementMatched = true;\n            dedupedMatches.push(result);\n        }\n    }\n    return dedupedMatches;\n}\n/** Verifies that there is at least one result in an array. */\nasync function _assertResultFound(results, queryDescriptions) {\n    const result = (await results)[0];\n    if (result == undefined) {\n        throw Error(`Failed to find element matching one of the following queries:\\n` +\n            queryDescriptions.map(desc => `(${desc})`).join(',\\n'));\n    }\n    return result;\n}\n/** Gets a list of description strings from a list of queries. */\nfunction _getDescriptionForLocatorForQueries(queries) {\n    return queries.map(query => typeof query === 'string'\n        ? _getDescriptionForTestElementQuery(query)\n        : _getDescriptionForComponentHarnessQuery(query));\n}\n/** Gets a description string for a `ComponentHarness` query. */\nfunction _getDescriptionForComponentHarnessQuery(query) {\n    const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n    const { name, hostSelector } = harnessPredicate.harnessType;\n    const description = `${name} with host element matching selector: \"${hostSelector}\"`;\n    const constraints = harnessPredicate.getDescription();\n    return (description +\n        (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : ''));\n}\n/** Gets a description string for a `TestElement` query. */\nfunction _getDescriptionForTestElementQuery(selector) {\n    return `TestElement for element matching selector: \"${selector}\"`;\n}\n/** Gets a description string for a `HarnessLoader` query. */\nfunction _getDescriptionForHarnessLoaderQuery(selector) {\n    return `HarnessLoader for element matching selector: \"${selector}\"`;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** An enum of non-text keys that can be used with the `sendKeys` method. */\n// NOTE: This is a separate enum from `@angular/cdk/keycodes` because we don't necessarily want to\n// support every possible keyCode. We also can't rely on Protractor's `Key` because we don't want a\n// dependency on any particular testing framework here. Instead we'll just maintain this supported\n// list of keys and let individual concrete `HarnessEnvironment` classes map them to whatever key\n// representation is used in its respective testing framework.\n// tslint:disable-next-line:prefer-const-enum Seems like this causes some issues with System.js\nvar TestKey;\n(function (TestKey) {\n    TestKey[TestKey[\"BACKSPACE\"] = 0] = \"BACKSPACE\";\n    TestKey[TestKey[\"TAB\"] = 1] = \"TAB\";\n    TestKey[TestKey[\"ENTER\"] = 2] = \"ENTER\";\n    TestKey[TestKey[\"SHIFT\"] = 3] = \"SHIFT\";\n    TestKey[TestKey[\"CONTROL\"] = 4] = \"CONTROL\";\n    TestKey[TestKey[\"ALT\"] = 5] = \"ALT\";\n    TestKey[TestKey[\"ESCAPE\"] = 6] = \"ESCAPE\";\n    TestKey[TestKey[\"PAGE_UP\"] = 7] = \"PAGE_UP\";\n    TestKey[TestKey[\"PAGE_DOWN\"] = 8] = \"PAGE_DOWN\";\n    TestKey[TestKey[\"END\"] = 9] = \"END\";\n    TestKey[TestKey[\"HOME\"] = 10] = \"HOME\";\n    TestKey[TestKey[\"LEFT_ARROW\"] = 11] = \"LEFT_ARROW\";\n    TestKey[TestKey[\"UP_ARROW\"] = 12] = \"UP_ARROW\";\n    TestKey[TestKey[\"RIGHT_ARROW\"] = 13] = \"RIGHT_ARROW\";\n    TestKey[TestKey[\"DOWN_ARROW\"] = 14] = \"DOWN_ARROW\";\n    TestKey[TestKey[\"INSERT\"] = 15] = \"INSERT\";\n    TestKey[TestKey[\"DELETE\"] = 16] = \"DELETE\";\n    TestKey[TestKey[\"F1\"] = 17] = \"F1\";\n    TestKey[TestKey[\"F2\"] = 18] = \"F2\";\n    TestKey[TestKey[\"F3\"] = 19] = \"F3\";\n    TestKey[TestKey[\"F4\"] = 20] = \"F4\";\n    TestKey[TestKey[\"F5\"] = 21] = \"F5\";\n    TestKey[TestKey[\"F6\"] = 22] = \"F6\";\n    TestKey[TestKey[\"F7\"] = 23] = \"F7\";\n    TestKey[TestKey[\"F8\"] = 24] = \"F8\";\n    TestKey[TestKey[\"F9\"] = 25] = \"F9\";\n    TestKey[TestKey[\"F10\"] = 26] = \"F10\";\n    TestKey[TestKey[\"F11\"] = 27] = \"F11\";\n    TestKey[TestKey[\"F12\"] = 28] = \"F12\";\n    TestKey[TestKey[\"META\"] = 29] = \"META\";\n})(TestKey || (TestKey = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an error which reports that no keys have been specified.\n * @docs-private\n */\nfunction getNoKeysSpecifiedError() {\n    return Error('No keys have been specified.');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Gets text of element excluding certain selectors within the element.\n * @param element Element to get text from,\n * @param excludeSelector Selector identifying which elements to exclude,\n */\nfunction _getTextWithExcludedElements(element, excludeSelector) {\n    const clone = element.cloneNode(true);\n    const exclusions = clone.querySelectorAll(excludeSelector);\n    for (let i = 0; i < exclusions.length; i++) {\n        exclusions[i].remove();\n    }\n    return (clone.textContent || '').trim();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { ComponentHarness, ContentContainerComponentHarness, HarnessEnvironment, HarnessPredicate, TestKey, _getTextWithExcludedElements, getNoKeysSpecifiedError, handleAutoChangeDetectionStatus, manualChangeDetection, parallel, stopHandlingAutoChangeDetectionStatus };\n"]},"metadata":{},"sourceType":"module"}